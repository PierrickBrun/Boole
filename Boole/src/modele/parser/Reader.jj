/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(Reader)package modele.parser;

public class Reader{  public static void main(String args []) throws ParseException  {    Reader parser = new Reader(System.in);
    boolean yes = true;    while (yes)    {      System.out.println("Reading from standard input...");      System.out.print("Enter an expression like \"1+(2+3)*4;\" :");      try      {        switch (Reader.one_line())        {          case 0 :           System.out.println("OK.");          break;          case 1 :           System.out.println("Goodbye.");
          yes = false;          break;          default :           break;        }      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        Reader.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(Reader)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN:
{< NUM : (< DIGIT >)+>
| < DIGIT : ["0"-"9"]>
}TOKEN :{
    < NOM : (< DIGIT >|<ALPHA1>){1}(< DIGIT >|< ALPHA2 >)+ >
| < ALPHA1 : ["A" - "Z"]>
| < ALPHA2 : ["a" - "z"]>
}
/*circuit Test<1|Non(1,1)->#1(2#1)>
<2|Non(1,1)->#1(2#1,3#3),#2(1#1)>
*/
TOKEN:{
  < CIRCUIT : "circuit"|"CIRCUIT">| < STATE : "bas"|"haut"|"BAS"|"HAUT">
}
int one_line() :{}{  < CIRCUIT >circuit()";;"  {    return 0;  }| ";;"  {    return 1;  }}void circuit() :{}{  < NOM >(composant())+}

void composant():{}
{
  "<"< NUM >"|"< NOM >"("< NUM >","< NUM >")"(< STATE >)?"->"(sortie())*}

void sortie():{}
{">"
| "#"< NUM >"("lien()sortie2()
}

void sortie2():{}
{
">"
| ",#"< NUM >"("lien()sortie2()
}

void lien():{}
{ < NUM >"#"< NUM >lien2()
}

void lien2():{}
{")"
| ","< NUM >"#"< NUM >lien2()
}/*void term() :{}{  unary()  (    (      < MULTIPLY >    | < DIVIDE >    )    unary()  )*}void unary() :{}{  < MINUS > element()| element()}void element() :{}{  < CONSTANT >| "(" sum() ")"}*/
